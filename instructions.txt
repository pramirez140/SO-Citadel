The Citadel System

=== PORT ALLOCATION ===
Ramírez Lázaro, Pablo (AD) (IA)    8685-8689 ICEDD
Rodriguez Carmona, Santiago (IA)    8690-8694 ICEDD
=======================

King Viserys is dead. The golden thread that once bound the realm has broken, and the trust among the Great Houses has evaporated. In this climate of tension, traditional trade routes are no longer safe, and alliances unravel as quickly as they are forged. Ravens fly toward castles bearing banners of dragons, green and black, but they do not carry messages of war, only an urgent need: to survive the coming political winter.

In this chaos, the Archmaesters of the Citadel have issued you a commission. Not to build a system of war, but a new network of trust and trade capable of operating in a fractured realm with no central power. You must design The Citadel System, a decentralized network that allows the Great Houses to forge alliances and then establish secure trade routes.

The main goal of the system is for the different Realms to be able to form Alliances among themselves in order to later Trade. To establish communication routes, the geography of the continent must be respected; therefore, a messenger must pass through all intermediate kingdoms (hops) carrying a raven until it reaches its destination. Once there, the sent raven will fly directly back to the origin with the reply.

To send multiple messages at once, the main process of each Realm (called the Maester) will rely on several assistants (Envoys). When a player wishes to initiate an action, such as requesting an alliance or trading, the Maester will assign the task to a free Envoy. That Envoy will handle all communication management for that specific task, allowing the Maester to manage multiple operations simultaneously. Coordination between the Maester and their Envoys will be one of the key design challenges.

Your task is to design and implement all the software needed to manage this ecosystem, following the specifications that will be provided. This project requires special emphasis on robustness, efficiency, and scalability, so that despite possible interruptions or sabotage attempts, the system can continue to operate smoothly.

To facilitate the process, development will be divided into incremental phases. Each phase will detail the functionalities to implement, the limitations, and provide tests to validate the progress of your work.
 

General Description
A first functional overview of the system’s process architecture is shown in Figure 2. The architecture consists of a network made up of multiple independent Maester processes, where each process represents one of the Great Houses and communicates with the others to form a web of connections.


Figure 2. Citadel System: functional scheme.
 

The Maester processes act as the main nodes of the network, each representing a Noble House. The main goal is for them to establish Alliances among themselves and later be able to Trade. Communication will not be direct; a message must pass through several intermediate nodes (hops) to reach its destination, simulating the route of an emissary on horseback.
To handle concurrency and avoid bottlenecks in the main process, each Maester will have several assistants (Envoys). When a player wishes to start an action, such as requesting an alliance or sending a trade list, the Maester will assign the task to a free Envoy. That Envoy will manage all network communication for that specific task. This allows the Maester to handle multiple operations simultaneously, focusing on management and routing while the Envoys carry out missions.
In summary, the main objective of the system is to create a robust communication network where nodes can forge alliances and trade, managing the complexity of indirect communication and internal concurrency.
To design and implement the project, it is recommended to read the full statement carefully.
To make development easier, four phases have been planned:
1.	Phase 1: creation of the Maester process. The network and Maester configuration file reading will be implemented, along with the command terminal containing all user commands to inspect realms, trade, and forge alliances.
2.	Phase 2: implementation of basic connectivity among the different Maesters, including routing logic (hops). Alliances will begin to form, and trading will be enabled.
3.	Phase 3: implementation of file transfer for alliances and trade. Each Maester will manage its product inventory and respond to purchase requests from its allies.
4.	Phase 4: introduction of the Envoy processes. The code must be adapted so that the Maester delegates missions to the Envoys, allowing multiple alliance or trade requests to be sent concurrently.
 

Phase 1: Valar Compilis
In Phase 1, the design and programming of the system’s main process, the Maester, will begin.
At this stage, the goal is to establish the foundations of the program: its initial configuration and user interface, without yet implementing network communication. The Maester process must be able to read its configuration files and respond to a set of user-entered commands (see Table 1).
Configuration file – Maester (maester.dat)

This text file will contain the basic information and routing table of the Maester in the following format.

•	The name of the realm.
•	The path to the folder where the user’s files are located.
•	The number of Envoys it will have.
•	The IP and port (each on a separate line ending with ‘\n’) where the Maester will
listen for connections.
•	A section beginning with --- ROUTES --- that defines the connections. Some entries will have a known IP and port, while others may contain *.*.*.* to indicate that the realm exists but its route is not directly known.
An example of a configuration text file is shown in Figure 3.

Figure 3. Configuration file of a Maester process.

Inventory File – Maester (stock.db)
Each Maester will manage their realm’s inventory through the official ledger. This ledger is not a simple scroll; it is written in a secret code that only the Maesters can decipher, protecting the house’s trade secrets.
 

Technically, it is a binary file. Each entry in the ledger defines a product with the following fields:

•	Name: char name[100];
•	Quantity: int amount;
•	Weight: float weight;

The inventory record must be preserved between executions. Any change in stock must be reflected in the inventory file to ensure persistence.
Command Terminal

The Maester process must handle an interactive terminal. Most of the time, it will display activity logs of the requests it receives or forwards to the next node. The terminal must always remain active so that the user can enter custom commands. These commands are case-insensitive.

COMMAND	DESCRIPTION
LIST REALMS	Displays all realms listed in the configuration
file.
PLEDGE <REALM> <sigil.jpg>	Initiates an alliance request to another realm.
PLEDGE RESPOND <REALM> ACCEPT / REJECT	Responds affirmatively or negatively to an
alliance request you have received.
LIST PRODUCTS <REALM>	Requests the list of products from a realm
(requires a prior alliance).
LIST PRODUCTS	If no realm is specified, it will display your own products. No alliance is required, since they
belong to your own Maester.
START TRADE <REALM>	Starts an interactive session to create a “shopping list.” Displays the available products (previously obtained with LIST PRODUCTS) and
allows the user to add them to the list.
PLEDGE STATUS	Shows the status of your alliances (pending,
allied).
ENVOY STATUS	Shows the status of all your Envoys.
EXIT	Ends execution.
Table 1. List of extended commands.


For the START TRADE command, a menu must be displayed like the one shown in the
example, allowing the user to build a “shopping list” to send to the requested realm.
 

For this first phase, the commands in this menu must be detected using invented products (you may use your own). When a trade session ends, the shopping list must be written to a file. This file will later be used to send data to other realms. The format of this file is flexible, but it must be a text file.


$montserrat:> Maester config.dat stock.db

Maester of Dragonstone initialized. The board is set.
$ PLEDGE TheVale sigil.jpg
Pledge sent to TheVale. Envoy 1 is on its way.
$ PLEDGE STATUS
-	TheVale: PENDING
-	KingsLanding: PENDING
-	Driftmark: PENDING
$ ENVOY STATUS
-	Envoy 1: ON_MISSION (PLEDGE to TheVale)
-	Envoy 2: FREE
-	Envoy 3: FREE
$ LIST PRODUCTS KingsLanding
ERROR: You must have an alliance with KingsLanding to trade.
$ PLEDGE KingsLanding sigil.jpg
Pledge sent to KingsLanding. Envoy 2 is on its way.
$ something else
Unknown command
$ ENVOY STATUS
-	Envoy 1: ON_MISSION (PLEDGE to TheVale)
-	Envoy 2: ON_MISSION (PLEDGE to KingsLanding)
-	Envoy 3: FREE
$
>>> Alliance with The Vale forged successfully!
$ PLEDGE STATUS
-	TheVale: ALLIED
-	KingsLanding: ON_PENDING
-	Driftmark: PENDING
$ LIST PRODUCTS TheVale
Listing products from TheVale:
1.	Myrish Lace (150 units)
2.	Sweetwine (80 units)
$ START TRADE TheVale
Entering trade mode with TheVale.
Available products: Myrish Lace, Sweetwine. (trade)> add Myrish Lace 10
(trade)> add Sweetwine 5 (trade)> send
Trade list sent to TheVale.
… next figure

Figure 4.1. Execution of a Maester process.
 















Item	|	Value	(Gold)	|	Weight (Stone)
Antlered Helm	|	250		|	4.5
Warhammer of Bronze	|	400		|	8.0
Stormlands Ale Barrel	|	80		|	10.0
Ship Timber Plank	|	60		|	15.0
Salted Fish Barrel	|	55		|	20.0
Wine Cask	|	120		|	5.0
Leather Riding Boots	|	90		|	2.0
Bronze Helm	|	140		|	3.5
Woolen Blanket	|	30		|	2.5
Iron Dagger	|	35		|	1.2
Grain Sack	|	40		|	10.0
Total Entries: 11					
$ EXIT					




Figure 4.2. Execution of a Maester process, command examples.
 

Requirements:
•	Design and program the maester executable.
•	On startup, the Maester must process its configuration files (.dat and .db) and store the information in the corresponding data structures.
•	The Maester must recognize all commands listed in Table 1. For this phase:
o	Fully implement the local functionality of the following commands: LIST REALMS, LIST PRODUCTS (without realm), EXIT, and START TRADE.
o	For the remaining commands, the program should simply display "Command OK" to indicate that the command was recognized.
o	The command recognition system must be robust. If a command is invalid, it should display "Unknown command". If a command is valid but incomplete (e.g., PLEDGE without arguments), it should display a free- form help message such as: Did you mean to send a pledge? Please review syntax.
 

Phase 1 Considerations:
•	Once all processes have finished execution, any significant dynamically allocated memory must be freed.
•	If realm names contain the character &, it must be removed. This is due to the system’s communication protocol described in the Annex. The protocol is case- sensitive.
•	Commands are case-insensitive.
•	You may assume that the configuration file format is correct.
•	The use of functions such as printf, scanf, gets, puts, etc. is forbidden. Interaction with the screen and files must be done exclusively through read (for reading) and write (for writing). The use of asprintf and similar functions is allowed.
•	The use of system, popen, stat, or any related variants is forbidden.
•	The application must remain stable and function correctly. Infinite loops, core dumps, busy waits, or compiler warnings are not acceptable. All possible error conditions must be properly handled; if an error occurs, the program must inform the user and continue running whenever possible.
•	From now until the end of the project, the Maester process may be terminated either through the appropriate command or by pressing CTRL+C. The system must handle this gracefully, releasing all resources and closing everything properly.
•	A Makefile is mandatory for generating the executable.
•	It is not enough for the file you upload to have a .tar extension; it must be extractable using the tar command. Any project or checkpoint that cannot be extracted this way will not be graded.
•	The code must be properly modularized. It is not permitted to place everything in a single .c file, and a Makefile is mandatory. If the submission does not compile with the make command for any reason, it will be graded as not approved (2).
•	Alongside the code, you must submit an explanation of how the phase was designed and structured. It is mandatory to perform this analysis before programming and validate it with the course instructors. See Annex III for more details. The report must clearly and understandably include:
o	Diagrams explaining the created processes.
o	The data structures used and the justification for their selection.
